import ctypes
import numpy as np
import os
from scripts import constants as constant


class RunetMatrix(ctypes.Structure):
    _fields_ = [
        ("rows", ctypes.c_int),
        ("cols", ctypes.c_int),
        ("data", ctypes.POINTER(ctypes.c_float)),
    ]

class CWrapper:
    """
    The class which handles and provides way to interact
    with the c libary code.
    """

    def __init__(self):
        """
        Initializes the ctypes library and calls the internal
        functions to map the api with c code
        """

        if not os.path.exists(constant.LIB_PATH):
            FileNotFoundError(f"Library binary file not found at {constant.LIB_PATH}")

        self._lib = ctypes.CDLL(constant.LIB_PATH)
        self._network = None

        self._runet_matrix_create_init()
        self._runet_network_from_file_init()
        self._runet_network_predict_init()
        self._runet_network_summary_init()

    def runet_matrix_create(self, data: list | np.ndarray):
        """
        Calls the runet_matrix_create api from the c library,
        which creates a matrix.

        Args:
            data (list | np.ndarray): The raw list of data to be stored inside the matrix.

        Returns:
            ctypes._NamedFuncPointer: A c-style pointer of the Matrix.
        """

        np_data = np.array(data, dtype=np.float32)

        if len(np_data.shape) == 1:
            rows, cols = 1, np_data.shape[0]
        else:
            rows, cols = np_data.shape

        c_data = np_data.ctypes.data_as(ctypes.POINTER(ctypes.c_float));
        return self._lib.runet_matrix_create(rows, cols, c_data)

    def runet_network_from_file(self, path: str) -> int:
        """
        Calls the runet_network_from_file api from the c library,
        which creates a network for layers.

        Args:
            path (str): The absolute path to the .bin file of the model.

        Returns:
            int: The status code specifying if it was successfull or not.

        Note:
            Only the .bin file generated by the RunetEngine methods will
            be read or else the function will throw an error.
        """

        if not os.path.exists(path):
            raise FileNotFoundError(f"File not found at path {path}.")

        status = ctypes.c_int(0)

        self._network = self._lib.runet_network_from_file(
            path.encode('utf-8'),
            ctypes.byref(status)
        )
        return status.value

    def runet_network_summary(self):
        """
        Calls the runet_network_summary api from the c library,
        which prints the summary of the current network.
        """
        if self._network is None:
            return

        self._lib.runet_network_summary(self._network)

    def runet_network_predict(self, c_input_ptr) -> np.ndarray:
        """
        Calls the runet_network_predict api from the c library,
        which runs the infernece engine and makes the prediction for the
        given input.

        Args:
            c_input_ptr (ctypes._NamedFuncPointer): A c-style pointer to Matrix.

        Returns:
            np.ndarray: A numpy array holding the result
        """

        c_output_ptr = ctypes.POINTER(RunetMatrix)()
        status = self._lib.runet_network_predict(
            self._network,
            c_input_ptr,
            ctypes.byref(c_output_ptr)
        )

        if status < 0:
            raise RuntimeError(f"Inference Failed with status code: {status}.\
                \nMessage: {constant.STATUS_CODE_MESSAGES[status]}")

        out_rows = c_output_ptr.contents.rows
        out_cols = c_output_ptr.contents.cols
        total_elements = out_rows * out_cols

        out_buffer = ctypes.cast(c_output_ptr.contents.data,
                                 ctypes.POINTER(ctypes.c_float * total_elements))
        return np.frombuffer(out_buffer.contents, dtype=np.float32).copy()

    def _runet_matrix_create_init(self):
        """
        Binds the runet_matrix_create function from the C library
        """
        self._lib.runet_matrix_create.restype = ctypes.POINTER(RunetMatrix);
        self._lib.runet_matrix_create.argtypes = [
            ctypes.c_int,
            ctypes.c_int,
            ctypes.POINTER(ctypes.c_float)
        ]

    def _runet_network_from_file_init(self):
        """
        Binds the runet_network_from_file function from the C library
        """
        self._lib.runet_network_from_file.restype = ctypes.c_voidp
        self._lib.runet_network_from_file.argtypes = [
            ctypes.c_char_p,
            ctypes.POINTER(ctypes.c_int)
        ]

    def _runet_network_predict_init(self):
        """
        Binds the runet_network_predict function from the C library
        """
        self._lib.runet_network_predict.restype = ctypes.c_int
        self._lib.runet_network_predict.argtypes = [
            ctypes.c_void_p,
            ctypes.POINTER(RunetMatrix),
            ctypes.POINTER(ctypes.POINTER(RunetMatrix))
        ]

    def _runet_network_summary_init(self):
        """
        Binds the runet_network_summary function from the C library
        """
        self._lib.runet_network_summary.restype = None
        self._lib.runet_network_summary.argtypes = [
            ctypes.c_void_p
        ]
